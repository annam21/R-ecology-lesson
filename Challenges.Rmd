---
title: "Challenges"
author: "Anna Moeller"
date: "8/31/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## intro-with-data

> ### Challenge
>
> Can you solve the following mathematical equations using R? 
>
> * 106 * 8
> * 1 + 2/3 * 4
> * (1+2)/3 * 4
> * (37+89)/12
> * $\sqrt{1654}$ 
> * 18\% of 97.65
> * log(100)
> * log(100, base = 10)
> * mean of: 34, 26, 65, 46, 27
>
> ```{r, answer=TRUE, results="markup", purl=FALSE}
>
>
> 106 * 8
> 1 + 2/3 * 4
> (1+2)/3 * 4
> (37+89)/12
> sqrt(1654)
> .18 * 97.65
## Notice the default is base e
> log(100) 
> log(100, base = 10)
> (34 + 26 + 65 + 46 + 27)/5



> ### Challenge
>
> Based on the output of `str(surveys)`, can you answer the following questions?
>
> * How many rows and how many columns are in this object?
> * What is the difference in how R stores integer columns (int) versus character columns (chr)?
> * How does R store missing data? 
> * What is the class of the object `surveys`?
>
> ```{r, answer=TRUE, results="markup", purl=FALSE}
>
> str(surveys)
>
> ## * how many rows: 34786,  how many columns: 13
> ## * Integers do not have "" but characters do
> ## * Missing data are stored as NA
> ## * class: data.frame
>
> ```


Can go anywhere we need an additional challenges 
> ### Debugging challenge
>
> Can you interpret these error messages and fix the code? 
>
> * install.packages(tidyr)
> * 
>
> ```{r, answer=TRUE, results="hide", purl=FALSE}
>
> install.packages("tidyr")
>
> ```
> Why isn't this code rounding pi to 2 digits? 
>
> round(2, 3.1415)
>
> ```{r, answer=TRUE, results="markup", purl=FALSE}
>
> ## * The arguments are switched or need to be labeled
> round(3.1415, 2)
> round(digits = 2, x = 3.1415)
>
> ```
> What are the arguments for the `plot()` function?
>
> ```{r, answer=TRUE, results='hide', purl=FALSE}
>
> ## ?plot
> args(plot)
>
> ```

02-dplyr 
> ### Challenge {.challenge}
>
>  Using pipes, subset the `surveys` data to include animals collected before
>  1995 and retain only the columns `year`, `sex`, and `weight`.
> 
> 
> ```{r, answer=TRUE, eval=FALSE, purl=FALSE}
> surveys %>%
>     filter(year < 1995) %>%
>     select(year, sex, weight)
> ```

```{r, eval=FALSE, purl=TRUE, echo=FALSE}
## Pipes Challenge:
##  Using pipes, subset the data to include animals collected
##  before 1995, and retain the columns `year`, `sex`, and `weight.`
```

> ### Challenge {.challenge}
>
>  Create a new data frame from the `surveys` data that meets the following
>  criteria: contains only the `species_id` column and a new column called
>  `hindfoot_cm` containing the `hindfoot_length` values converted to centimeters.
>  In this `hindfoot_cm` column, there are no `NA`s and all values are less
>  than 3.
>
>  **Hint**: think about how the commands should be ordered to produce this data frame!
> 
> ```{r, answer=TRUE, eval=FALSE, purl=FALSE}
> surveys_hindfoot_cm <- surveys %>%
>     filter(!is.na(hindfoot_length)) %>%
>     mutate(hindfoot_cm = hindfoot_length / 10) %>%
>     filter(hindfoot_cm < 3) %>%
>     select(species_id, hindfoot_cm)

```{r, eval=FALSE, purl=TRUE, echo=FALSE}
## Mutate Challenge:
##  Create a new data frame from the `surveys` data that meets the following
##  criteria: contains only the `species_id` column and a new column called
##  `hindfoot_cm` containing the `hindfoot_length` values converted to centimeters.
##  In this `hindfoot_cm` column, there are no `NA`s and all values are less
##  than 3.

##  Hint: think about how the commands should be ordered to produce this data frame!
```


> ```
 > ### Challenge {.challenge}
>
> 1. How many animals were caught in each `plot_type` surveyed?
>
> ```{r, answer=TRUE, purl=FALSE}
> surveys %>%
>     count(plot_type) 
> ```
>
> 2. Use `group_by()` and `summarize()` to find the mean, min, and max hindfoot
> length for each species (using `species_id`). 
>
> ```{r, answer=TRUE, purl=FALSE}
> surveys %>%
>     filter(!is.na(hindfoot_length)) %>%
>     group_by(species_id) %>%
>     summarize(
>         mean_hindfoot_length = mean(hindfoot_length),
>         min_hindfoot_length = min(hindfoot_length),
>         max_hindfoot_length = max(hindfoot_length)
>     )
> ```
>
> 3. What was the heaviest animal measured in each year? Return the columns `year`,
> `genus`, `species_id`, and `weight`.
>
> ```{r, answer=TRUE, purl=FALSE}
> surveys %>%
>     filter(!is.na(weight)) %>%
>     group_by(year) %>%
>     filter(weight == max(weight)) %>%
>     select(year, genus, species, weight) %>%
>     arrange(year)
> ```

```{r, eval=FALSE, purl=TRUE, echo=FALSE}
## Count Challenges:
##  1. How many animals were caught in each `plot_type` surveyed?

##  2. Use `group_by()` and `summarize()` to find the mean, min, and max
## hindfoot length for each species (using `species_id`). Also add the number of
## observations (hint: see `?n`).

##  3. What was the heaviest animal measured in each year? Return the
##  columns `year`, `genus`, `species_id`, and `weight`.
```

> ### Challenge {.challenge}
>
> 1. Spread the `surveys` data frame with `year` as columns, `plot_id` 
>   as rows, and the
>   number of genera per plot as the values. You will need to summarize before
>   reshaping, and use the function `n_distinct()` to get the number of unique
>   genera within a particular chunk of data. It's a powerful function! See
>   `?n_distinct` for more.
> 
> ```{r, answer=TRUE, purl=FALSE}
> surveys_spread_genera <- surveys %>%
>   group_by(plot_id, year) %>%
>   summarize(n_genera = n_distinct(genus)) %>%
>   spread(year, n_genera)
> 
> head(surveys_spread_genera)
> ```
>
> 2. Now take that data frame and `gather()` it again, so each row is a unique
>    `plot_id` by `year` combination.
>
> ```{r, answer=TRUE, purl=FALSE}
> surveys_spread_genera %>%
>   gather("year", "n_genera", -plot_id)
> ```
>
> 3. The `surveys` data set has
>    two measurement columns: `hindfoot_length` and `weight`.  This makes it
>    difficult to do things like look at the relationship between mean values of
>    each measurement per year in different plot types. Let's walk through a
>    common solution for this type of problem. First, use `gather()` to create a
>     dataset where we have a key column called `measurement` and a
>    `value` column that takes on the value of either `hindfoot_length` or
>    `weight`. *Hint*: You'll need to specify which columns are being gathered.
>
> ```{r, answer=TRUE, purl=FALSE}
> surveys_long <- surveys %>%
>   gather("measurement", "value", hindfoot_length, weight)
> ```
>
> 4. With this new data set, calculate the average of each
>    `measurement` in each `year` for each different `plot_type`. Then
>    `spread()` them into a data set with a column for `hindfoot_length` and
>    `weight`. *Hint*: You only need to specify the key and value
>    columns for `spread()`.
>
> ```{r, answer=TRUE, purl=FALSE}
> surveys_long %>%
>   group_by(year, measurement, plot_type) %>%
>   summarize(mean_value = mean(value, na.rm=TRUE)) %>%
>   spread(measurement, mean_value)
> ```

```{r, eval=FALSE, purl=TRUE, echo=FALSE}
## Reshaping challenges

## 1. Spread the `surveys` data frame with `year` as columns, `plot_id` as rows, and the number of genera per plot as the values. You will need to summarize before reshaping, and use the function `n_distinct()` to get the number of unique genera within a particular chunk of data. It's a powerful function! See `?n_distinct` for more.

## 2. Now take that data frame and `gather()` it again, so each row is a unique `plot_id` by `year` combination.

## 3. The `surveys` data set has two measurement columns: `hindfoot_length` and `weight`. This makes it difficult to do things like look at the relationship between mean values of each measurement per year in different plot types. Let's walk through a common solution for this type of problem. First, use `gather()` to create a dataset where we have a key column called `measurement` and a `value` column that takes on the value of either `hindfoot_length` or `weight`. *Hint*: You'll need to specify which columns are being gathered.

## 4. With this new data set, calculate the average of each `measurement` in each `year` for each different `plot_type`. Then `spread()` them into a data set with a column for `hindfoot_length` and `weight`. *Hint*: You only need to specify the key and value columns for `spread()`.
```


03-visualization-gplot2
> ### Challenge (optional)
>
> Scatter plots can be useful exploratory tools for small datasets. For data
> sets with large numbers of observations, such as the `surveys_complete` data
> set, overplotting of points can be a limitation of scatter plots. One strategy
> for handling such settings is to use hexagonal binning of observations. The
> plot space is tessellated into hexagons. Each hexagon is assigned a color
> based on the number of observations that fall within its boundaries.  To use
> hexagonal binning with **`ggplot2`**, first install the R package `hexbin`
> from CRAN:
>
>
> ```{r, eval = FALSE}
> install.packages("hexbin")
> library("hexbin")
> ```
>
> Then use the `geom_hex()` function:
>
> ```{r, eval = FALSE}
> surveys_plot +
>  geom_hex()
> ```
>
> - What are the relative strengths and weaknesses of a hexagonal bin plot
>   compared to a scatter plot? Examine the above scatter plot and compare it
>   with the hexagonal bin plot that you created.

> ### Challenge
>
> Use what you just learned to create a scatter plot of `weight` over
> `species_id` with the plot types showing in different colors.
> Is this a good way to show this type of data?
>
> ```{r scatter-challenge-answer, answer=TRUE, purl=FALSE}
> ggplot(data = surveys_complete, 
>        mapping = aes(x = species_id, y = weight)) +
>    geom_point(aes(color = plot_type))
> ```

```{r scatter-challenge, echo = FALSE, eval = FALSE, purl = TRUE}
### Challenge with scatter plot:
##
##  Use what you just learned to create a scatter plot of `weight`
## over `species_id` with the plot types showing in different colors.
## Is this a good way to show this type of data?
```

> ### Challenges
>
> Boxplots are useful summaries, but hide the *shape* of the distribution. For
> example, if there is a bimodal distribution, it would not be observed with a
> boxplot. An alternative to the boxplot is the violin plot (sometimes known as 
> a beanplot), where the shape (of the density of points) is drawn.
>
> - Replace the box plot with a violin plot; see `geom_violin()`.
>
> In many types of data, it is important to consider the *scale* of the
> observations.  For example, it may be worth changing the scale of the axis to
> better distribute the observations in the space of the plot.  Changing the scale
> of the axes is done similarly to adding/modifying other components (i.e., by
> incrementally adding commands). Try making these modifications:
>
> - Represent weight on the log~10~ scale; see `scale_y_log10()`.
>
> So far, we've looked at the distribution of weight within species. Try making
> a new plot to explore the distribution of another variable within each species.
>
> - Create boxplot for `hindfoot_length`.  Overlay the boxplot layer on a jitter
>   layer to show actual measurements.
>
> - Add color to the data points on your boxplot according to the plot from which
>   the sample was taken (`plot_id`).

> Hint: Check the class for `plot_id`. Consider changing the class of `plot_id` 
> from integer to factor. Why does this change how R makes the graph?

```{r boxplot-challenge, eval = FALSE, purl = TRUE, echo = FALSE}
## Challenge with boxplots:
##  Start with the boxplot we created:
ggplot(data = surveys_complete, mapping = aes(x = species_id, y = weight)) +
  geom_boxplot(alpha = 0) +
  geom_jitter(alpha = 0.3, color = "tomato")

##  1. Replace the box plot with a violin plot; see `geom_violin()`.

##  2. Represent weight on the log10 scale; see `scale_y_log10()`.

##  3. Create boxplot for `hindfoot_length` overlaid on a jitter layer.

##  4. Add color to the data points on your boxplot according to the
##  plot from which the sample was taken (`plot_id`).
##  *Hint:* Check the class for `plot_id`. Consider changing the class
##  of `plot_id` from integer to factor. Why does this change how R
##  makes the graph?

```

> ### Challenge
>
> Use what you just learned to create a plot that depicts how the average weight
> of each species changes through the years.
> 
> ```{r average-weight-time-series, answer=TRUE, purl=FALSE}
> yearly_weight <- surveys_complete %>%
>                 group_by(year, species_id) %>%
>                  summarize(avg_weight = mean(weight))
> ggplot(data = yearly_weight, mapping = aes(x=year, y=avg_weight)) +
>    geom_line() +
>    facet_wrap(vars(species_id)) +
>    theme_bw()
>```


```{r, eval = FALSE, purl = TRUE, echo = FALSE}
### Plotting time series challenge:
##
##  Use what you just learned to create a plot that depicts how the
##  average weight of each species changes through the years.

```


> ### Challenge
>
> With all of this information in hand, please take another five minutes to either
> improve one of the plots generated in this exercise or create a beautiful graph
> of your own. Use the RStudio [**`ggplot2`** cheat sheet](https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf) 
> for inspiration.
>
> Here are some ideas:
>
> * See if you can change the thickness of the lines.
> * Can you find a way to change the name of the legend? What about its labels?
> * Try using a different color palette (see
>   http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/).

```{r final-challenge, eval = FALSE, purl = TRUE, echo = FALSE}
### Final plotting challenge:
##  With all of this information in hand, please take another five
##  minutes to either improve one of the plots generated in this
##  exercise or create a beautiful graph of your own. Use the RStudio
##  ggplot2 cheat sheet for inspiration:
##  https://www.rstudio.com/wp-content/uploads/2015/08/ggplot2-cheatsheet.pdf
```
